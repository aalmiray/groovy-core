= Semantics

This chapter covers the semantics of the Groovy programming language.

== Statements

=== Variable definition

Variables can be defined using either their type (like `String`) or by using the keyword `def`:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=variable_definition_example,indent=0]
----

`def` is a replacement for a type name. In variable definitions it is used to indicate that you don't care about the type. In variable definitions it is mandatory to either provide a type name explicitly or to use "def" in replacement. This is needed to the make variable definitions detectable for the Groovy parser.

You can think of `def` as an alias of `Object` and you will understand it in an instant.

[NOTE]
Variable definition types can be refined by using generics, like in `List<String> names`.
To learn more about the generics support, please read the <<generics,generics section>>.

=== Variable assignment

You can assign values to variables for later use. Try the following:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=variable_assignment_example,indent=0]
----

==== Multiple assignment

Groovy supports multiple assignment, i.e. where multiple variables can be assigned at once, e.g.:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=multiple_assignment_example,indent=0]
----

You can provide types as part of the declaration if you wish:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=multiple_assignment_with_types,indent=0]
----

As well as used when declaring variables it also applies to existing variables:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=multiple_assignment_with_existing_variables,indent=0]
----

The syntax works for arrays as well as lists, as well as methods that return either of these:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=multiple_assignment_with_arrays_and_lists,indent=0]
----

==== Overflow and Underflow

If the left hand side has too many variables, excess ones are filled with null's:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=multiple_assignment_overflow,indent=0]
----

If the right hand side has too many variables, the extra ones are ignored:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=multiple_assignment_underflow,indent=0]
----

==== Object destructuring with multiple assignment

In the section describing the various <<groovy-operators,Groovy operators>>,
the case of the <<subscript-operator,subscript operator>> has been covered,
explaining how you can override the `getAt()`/`putAt()` method.

With this technique, we can combine multiple assignments and the subscript operator methods to implement _object destructuring_.

Consider the following immutable `Coordinates` class, containing a pair of longitude and latitude doubles,
and notice our implementation of the `getAt()` method:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=coordinates-class,indent=0]
----

Now let's instantiate this class and destructure its longitude and latitude:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=destructuring,indent=0]
----
<1> we create an instance of the `Coordinates` class
<2> then, we use a multiple assignment to get the individual longitude and latitude values
<3> and we can finally assert their values.

=== Control structures (WIP)
==== Conditional structures
===== if / else

Groovy supports the usual if - else syntax from Java

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=if_else_example,indent=0]
----

Groovy also supports the normal Java "nested" if then else if syntax:

[source,groovy]
----
if ( ... ) {
    ...
} else if (...) {
    ...
} else {
    ...
}
----

===== switch / case

The switch statement in Groovy is backwards compatible with Java code; so you can fall through cases sharing the same code for multiple matches.

One difference though is that the Groovy switch statement can handle any kind of switch value and different kinds of matching can be performed.

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=switch_case_example,indent=0]
----

Switch supports the following kinds of comparisons:

* Class case values matches if the switch value is an instance of the class
* Regular expression case values match if the `toString()` representation of the switch value matches the regex
* Collection case values match if the switch value is contained in the collection. This also includes ranges (since they are Lists)
* Closure case values match if the calling the closure returns a result which is true according to the <<Groovy-Truth,Groovy truth>>
* If none of the above are used then the case value matches if the case value equals the switch value

NOTE: +default+ must go at the end of the switch/case. While in Java the default can be placed anywhere in the switch/case, the default in Groovy is used more as an else than assigning a default case.

NOTE: when using a closure case value, the default `it` parameter is actually the switch value (in our example, variable `x`)

==== Looping structures
===== Classic for loop

Groovy supports the standard Java / C for loop:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=classic_for_loop_example,indent=0]
----

===== for in loop

The for loop in Groovy is much simpler and works with any kind of array, collection, Map, etc.

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=groovy_for_loop_example,indent=0]
----

[NOTE]
Groovy also supports the Java colon variation with colons: `for (char c : text) {}`,
where the type of the variable is mandatory.

===== while loop

Groovy supports the usual while {...} loops like Java:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=while_loop_example,indent=0]
----

==== Exception handling

Exception handling is the same as Java.

==== try / catch / finally

You can specify a complete +try-catch-finally+, a +try-catch+, or a +try-finally+ set of blocks.

NOTE: Braces are required around each block's body.

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=try_catch_example,indent=0]
----

We can put code within a 'finally' clause following a matching 'try' clause, so that regardless of whether the code in the 'try' clause throws an exception, the code in the finally clause will always execute:

[source,groovy]
----
include::{projectdir}/src/spec/test/SemanticsTest.groovy[tags=try_catch_finally_example,indent=0]
----

==== Multi-catch

With the multi catch block (since Groovy 2.0), we're able to define several exceptions to be catch and treated by the same catch block:

[source,groovy]
----
try {
    /* ... */
} catch ( IOException | NullPointerException e ) {
    /* one block to handle 2 exceptions */
}
----

=== Power assertion (TBD)
=== Labeled statements (TBD)

== Expressions (TBD)

=== GPath expressions (TBD)

== Promotion and coercion (TBD)

=== Number promotion (TBD)
=== Closure to type coercion
==== Assigning a closure to a SAM type
A SAM type is a type which defines a single abstract method. This includes:

[source,groovy]
.Functional interfaces
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=filter_sam_type,indent=0]
----

[source,groovy]
.Abstract classes with single abstract method
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=greeter_sam_type,indent=0]
----

Any closure can be converted into a SAM type using the `as` operator:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=assertions_explicit_closure_to_sam,indent=0]
----

However, the `as Type` expression is optional since Groovy 2.2.0. You can omit it and simply write:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=assertions_implicit_closure_to_sam,indent=0]
----

which means you are also allowed to use method pointers, as shown in the following example:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=assertions_implicit_closure_to_sam_and_method_pointer,indent=0]
----

==== Calling a method accepting a SAM type with a closure

The second and probably more important use case for closure to SAM type coercion is calling a method which accepts
a SAM type. Imagine the following method:

[source,groovy]
-----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=method_accepting_filter,indent=0]
-----

Then you can call it with a closure, without having to create an explicit implementation of the interface:

[source,groovy]
-----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=method_call_with_explicit_coercion,indent=0]
-----

But since Groovy 2.2.0, you are also able to omit the explicit coercion and call the method as if it used a closure:

[source,groovy]
-----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=method_call_with_implicit_coercion,indent=0]
-----

As you can see, this has the advantage of letting you use the closure syntax for method calls, that is to say put the
closure outside of the parenthesis, improving the readability of your code.

==== Closure to arbitrary type coercion

In addition to SAM types, a closure can be coerced to any type and in particular interfaces. Let's define the
following interface:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=foobar_interface,indent=0]
----

You can coerce a closure into the interface using the `as` keyword:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=foobar2closure_coercion,indent=0]
----

This produces a class for which all methods are implemented using the closure:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=foobarintf_assertions,indent=0]
----

But it is also possible to coerce a closure to any class. For example, we can replace the `interface` that we defined
with `class` without changing the assertions:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=closure2foobarclass,indent=0]
----

=== Map to type coercion

Usually using a single closure to implement an interface or a class with multiple methods is not the way to go. As an
alternative, Groovy allows you to coerce a map into an interface or a class. In that case, keys of the map are
interpreted as method names, while the values are the method implementation. The following example illustrates the
coercion of a map into an `Iterator`:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=coerce_map_to_iterator,indent=0]
----

Of course this is a rather contrived example, but illustrates the concept. You only need to implement those methods
that are actually called, but if a method is called that doesn't exist in the map a `MissingMethodException` or an
`UnsupportedOperationException` is thrown, depending on the arguments passed to the call,
as in the following example:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=define_x_interface,indent=0]
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=call_existing_method,indent=0]
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=call_non_existing_method,indent=0]
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=call_notimplemented_method,indent=0]
----

The type of the exception depends on the call itself:

* `MissingMethodException` if the arguments of the call do not match those from the interface/class
* `UnsupportedOperationException` if the arguments of the call match one of the overloaded methods of the interface/class

=== String to enum coercion

Groovy allows transparent +String+ (or +GString+) to enum values coercion. Imagine you define the following enum:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=state_enum,indent=0]
----

then you can assign a string to the enum without having to use an explicit `as` coercion:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=enum_coerce_assignment,indent=0]
----

It is also possible to use a +GString+ as the value:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=enum_coerce_assignment_gstring,indent=0]
----


However, this would throw a runtime error (+IllegalArgumentException+):
[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=enum_coerce_assignment_wrong,indent=0]
----

Note that it is also possible to use implicit coercion in switch statements:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=enum_switch_method,indent=0]
----

in particular, see how the `case` use string constants. But if you call a method that uses an enum with a +String+
argument, you still have to use an explicit `as` coercion:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=enum_switch_test,indent=0]
----

=== Custom type coercion

It is possible for a class to define custom coercion strategies by implementing the +asType+ method. Custom coercion
is invoked using the `as` operator and is never implicit. As an example,
imagine you defined two classes, +Polar+ and +Cartesian+, like in the following example:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=polar_class_header,indent=0]
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=polar_class_footer,indent=0]
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=cartesian_class,indent=0]
----

And that you want to convert from polar coordinates to cartesian coordinates. One way of doing this is to define
the +asType+ method in the +Polar+ class:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=polar_class_astype,indent=0]
----

which allows you to use the +as+ coercion operator:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=polar_astype_assert,indent=0]
----

Putting it all together, the +Polar+ class looks like this:
[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=polar_class_header,indent=0]
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=polar_class_astype,indent=4]
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=polar_class_footer,indent=0]
----

but it is also possible to define +asType+ outside of the +Polar+ class, which can be practical if you want to define
custom coercion strategies for "closed" classes or classes for which you don't own the source code, for example using
a metaclass:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=polar_metaclass_astype,indent=0]
----

=== Class literals vs variables and the as operator

Using the `as` keyword is only possible if you have a static reference to a class, like in the following code:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=as_keyword,indent=0]
----

But what if you get the class by reflection, for example by calling `Class.forName`?

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=clazz_greeter_header,indent=0]
----

Trying to use the reference to the class with the `as` keyword would fail:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=incorrect_as_usage,indent=0]
----

It is failing because the `as` keyword only works with class literals. Instead, you need to call the `asType` method:

[source,groovy]
----
include::{projectdir}/src/spec/test/CoercionTest.groovy[tags=fixed_as_usage,indent=0]
----

== Optionality (TBD)

=== Optional parentheses (TBD)
=== Optional semicolons (TBD)
=== Optional return keyword (TBD)
=== Optional public keyword (TBD)

[[Groovy-Truth]]
== The Groovy Truth (TBD)

=== Customizing the truth with asBoolean() methods (TBD)

== Typing (WIP)

=== Optional typing

Optional typing is the idea that a program can work even if you don't put an explicit type on a variable. Being a dynamic
language, Groovy naturally implements that feature, for example when you declare a variable:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/OptionalTypingTest.groovy[tags=optionaltyping_var,indent=0]
----
<1> `foo` is declared using an explicit type, `String`
<2> we can call the `toUpperCase` method on a `String`

Groovy will let you write this instead:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/OptionalTypingTest.groovy[tags=optionaltyping_var_def,indent=0]
----
<1> `foo` is declared using `def`
<2> we can still call the `toUpperCase` method, because the type of `aString` is resolved at runtime

So it doesn't matter that you use an explicit type here. It is in particular interesting when you combine this feature
with <<typechecking,static type checking>>, because the type checker performs type inference.

Likewise, Groovy doesn't make it mandatory to declare the types of a parameter in a method:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/OptionalTypingTest.groovy[tags=optionaltyping_orig,indent=0]
----

can be rewritten using `def` as both return type and parameter types, in order to take advantage of duck typing, as
illustrated in this example:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/OptionalTypingTest.groovy[tags=optionaltyping_def,indent=0]
----
<1> both the return type and the parameter types use `def`
<2> it makes it possible to use the method with `String`
<3> but also with `int`s since the `plus` method is defined

TIP: Using the `def` keyword here is recommanded to describe the intent of a method which is supposed to work on any
type, but technically, we could use `Object` instead and the result would be the same: `def` is, in Groovy, strictly
equivalent to using `Object`.

Eventually, the type can be removed altogether from both the return type and the descriptor. But if you want to remove
it from the return type, you then need to add an explicit modifier for the method, so that the compiler can make a difference
between a method declaration and a method call, like illustrated in this example:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/OptionalTypingTest.groovy[tags=optionaltyping_notype,indent=0]
----
<1> if we want to omit the return type, an explicit modifier has to be set.
<2> it is still possible to use the method with `String`
<3> and also with `int`s

TIP: Omitting types is in general considered a bad practice in method parameters or method return types for public APIs.
While using `def` in a local variable is not really a problem because the visibility of the variable is limited to the
method itself, while set on a method parameter, `def` will be converted to `Object` in the method signature, making it
difficult for users to know which is the expected type of the arguments. This means that you should limit this to cases
where you are explicitly relying on duck typing.

[[static-type-checking]]
=== Static type checking

By default, Groovy performs minimal type checking at compile time. Since it is primarily a dynamic language,
most checks that a static compiler would normally do aren't possible at compile time. A method added via runtime
metaprogramming might alter a class or object's runtime behavior. Let's illustrate why in the
following example:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_intro,indent=0]
----
<1> the `Person` class only defines two properties, `firstName` and `lastName`
<2> we can create an instance of Person
<3> and call a method named `formattedName`

It is quite common in dynamic languages for code such as the above example not to throw any error. How can this be?
In Java, this would typically fail at compile time. However, in Groovy, it will not fail at compile time, and if coded
correctly, will also not fail at runtime. In fact, to make this work at runtime, *one* possibility is to rely on
runtime metaprogramming. So just adding this line after the declaration of the `Person` class is enough:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_intro_magic,indent=0]
----

This means that in general, in Groovy, you can't make any assumption about the type of an object beyond its declaration
type, and even if you know it, you can't determine at compile time what method will be called, or which property will
be retrieved, and this is *perfectly fine*. This is how dynamic languages work, and it has a lot of interest.

However, if your program doesn't rely on dynamic features and that you come from the static world (in particular, from
a Java mindset), not catching such "errors" at compile time can be surprising. As we have seen in the previous example,
the compiler cannot be sure this is an error. To make it aware that it is, you have to explicitly instruct the compiler
that you are switching to a type checked mode. This can be done by annotating a class or a method with `@groovy.lang.TypeChecked`.

When type checking is activated, the compiler performs much more work:

* type inference is activated, meaning that even if you use `def` on a local variable for example, the type checker will be
able to infer the type of the variable from the assignments
* method calls are resolved at compile time, meaning that if a method is not declared on a class, the compiler will throw an error
* in general, all the compile time errors that you are used to find in a static language will appear: method not found, property not found,
incompatible types for method calls, number precision errors, ...

In this section, we will describe the behavior of the type checker in various situations and explain the limits of using
`@TypeChecked` on your code.

==== The `@TypeChecked` annotation

The `groovy.lang.TypeChecked` annotation enabled type checking. It can be placed on a class:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=typechecked_class,indent=0]
----

Or on a method:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=typechecked_method,indent=0]
----

In the first case, all methods, properties, fields, inner classes, ... of the annotated class will be type checked, whereas
in the second case, only the method and potential closures or anonymous inner classes that it contains will be type checked.

==== Type checking assignments

An object `o` of type `A` can be assigned to a variable of type `T` if and only if:

* `T` equals `A`

+

[.result]
====
[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_assign_equals,indent=0]
----
====

* _or_ `T` is one of `String`, `boolean`, `Boolean` or `Class`

+

[.result]
====
[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_assign_specialcase,indent=0]
----
====

* _or_ `o` is null and `T` is not a primitive type

+

[.result]
====
[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_assign_null,indent=0]
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_assign_null2prim,indent=0]
----
====

* _or_ `T` is an array and `A` is an array and the component type of `A` is assignable to the component type of `B`

+

[.result]
====
[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_assign_array,indent=0]
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_assign_array_fail,indent=0]
----
====

* _or_ `T` is an array and `A` is a list and the component type of `A` is assignable to the component type of `B`

+

[.result]
====
[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_assign_array_list,indent=0]
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_assign_array_list_fail,indent=0]
----
====

* _or_ `T` is a superclass of `A`

+

[.result]
====
[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_assign_superclass,indent=0]
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_assign_superclass_fail,indent=0]
----
====

* _or_ `T` is an interface implemented by `A`


+

[.result]
====
[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_assign_interface,indent=0]
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_assign_interface_fail,indent=0]
----
====

* _or_ `T` or `A` are a primitive type and their boxed types are assignable

+

[.result]
====
[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_assign_prim,indent=0]
----
====

* _or_ `T` extends `groovy.lang.Closure` and `A` is a SAM-type (single abstract method type)

+

[.result]
====
[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_closure_coercion,indent=0]
----
====

* _or_ `T` and `A` derive from `java.lang.Number` and conform to the following table


[cols="1,1,2a"]
.Number types (java.lang.XXX)
[[number-assignment]]
|===
|T |A |Examples

|Double
|Any but BigDecimal or BigInteger
| [source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_assign_to_double,indent=0]
----

|Float
|Any type but BigDecimal, BigInteger or Double
| [source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_assign_to_float,indent=0]
----

|Long
|Any type but BigDecimal, BigInteger, Double or Float
| [source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_assign_to_long,indent=0]
----

|Integer
|Any type but BigDecimal, BigInteger, Double, Float or Long
| [source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_assign_to_int,indent=0]
----

|Short
|Any type but BigDecimal, BigInteger, Double, Float, Long or Integer
| [source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_assign_to_short,indent=0]
----

|Byte
|Byte
| [source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_assign_to_byte,indent=0]
----

|===

==== List and map constructors

In addition to the assignment rules above, if an assignment is deemed invalid, in type checked mode, a _list_ literal or a _map_ literal `A` can be assigned
to a variable of type `T` if:

* the assignment is a variable declaration and `A` is a list literal and `T` has a constructor whose parameters match the types of the elements in the list literal
* the assignment is a variable declaration and `A` is a map literal and `T` has a no-arg constructor and a property for each of the map keys

For example, instead of writing:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_ctor_point_classic,indent=0]
----

You can use a "list constructor":

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_ctor_point_list,indent=0]
----

or a "map constructor":

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_ctor_point_map,indent=0]
----

If you use a map constructor, additional checks are done on the keys of the map to check if a property of the same name
is defined. For example, the following will fail at compile time:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_ctor_fail,indent=0]
----
<1> The type checker will throw an error `No such property: age for class: Person` at compile time

==== Method resolution

In type checked mode, methods are resolved at compile time. Resolution works by name and arguments. The return type is
irrelevant to method selection. Types of arguments are matched against the types of the parameters following those rules:

An argument `o` of type `A` can be used for a parameter of type `T` if and only if:

* `T` equals `A`

+

[.result]
====
[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_argparam_equals,indent=0]
----
====

* _or_ `T` is a `String` and `A` is a `GString`

+

[.result]
====
[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_argparam_specialcase,indent=0]
----
====

* _or_ `o` is null and `T` is not a primitive type

+

[.result]
====
[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_argparam_null,indent=0]
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_argparam_null2prim,indent=0]
----
====

* _or_ `T` is an array and `A` is an array and the component type of `A` is assignable to the component type of `B`

+

[.result]
====
[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_argparam_array,indent=0]
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_argparam_array_fail,indent=0]
----
====

* _or_ `T` is a superclass of `A`

+

[.result]
====
[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_argparam_superclass,indent=0]
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_argparam_superclass_fail,indent=0]
----
====

* _or_ `T` is an interface implemented by `A`

+

[.result]
====
[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_argparam_interface,indent=0]
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_argparam_interface_fail,indent=0]
----
====

* _or_ `T` or `A` are a primitive type and their boxed types are assignable

+

[.result]
====
[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_argparam_prim,indent=0]
----
====

* _or_ `T` extends `groovy.lang.Closure` and `A` is a SAM-type (single abstract method type)

+

[.result]
====
[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=stc_arg_closure_coercion,indent=0]
----
====

* _or_ `T` and `A` derive from `java.lang.Number` and conform to the same rules as <<number-assignment,assignment of numbers>>

If a method with the appropriate name and arguments is not found at compile time, an error is thrown. The difference with "normal" Groovy is
illustrated in the following example:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=method_not_type_checked,indent=0]
----
<1> `printLine` is an error, but since we're in a dynamic mode, the error is not caught at compile time

The example above shows a class that Groovy will be able to compile. However, if you try to create an instance of `MyService` and call the
`doSomething` method, then it will fail *at runtime*, because `printLine` doesn't exist. Of course, we already showed how Groovy could make
this a perfectly valid call, for example by catching `MethodMissingException` or implementing a custom meta-class, but if you know you're
not in such a case, `@TypeChecked` comes handy:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=method_not_type_checked,indent=0]
----
<1> `printLine` is this time a compile-time error

Just adding `@TypeChecked` will trigger compile time method resolution. The type checker will try to find a method `printLine` accepting
a `String` on the `MyService` class, but cannot find one. It will fail compilation with the following message:

`Cannot find matching method MyService#printLine(java.lang.String)`

====
IMPORTANT: It is important to understand the logic behind the type checker: it is a compile-time check, so by definition, the type checker
is not aware of any kind of *runtime* metaprogramming that you do. This means that code which is perfectly valid without `@TypeChecked` will
*not* compile anymore if you activate type checking. This is in particular true if you think of duck typing: +

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=ducktyping_failure,indent=0]
----
<1> we define a `Duck` class which defines a `quack` method
<2> we define another `QuackingBird` class which also defines a `quack` method
<3> `quacker` is loosely typed, so since the method is `@TypeChecked`, we will obtain a compile-time error
<4> even if in non type-checked Groovy, this would have passed

There are possible workarounds, like introducing an interface, but basically, by activating type checking, you gain type safety
but you loose some features of the language. Hopefully, Groovy introduces some features like flow typing to reduce the gap between
type-checked and non type-checked Groovy.
====

[[type-inference]]
==== Type inference

===== Principles

When code is annotated with `@TypeChecked`, the compiler performs type inference. It doesn't simply rely on static types, but also uses various
techniques to infer the types of variables, return types, literals, ... so that the code remains as clean as possible even if you activate the
type checker.

The simplest example is infering the type of a variable:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=simple_var_type_inference,indent=0]
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=simple_var_type_inference_fail,indent=0]
----
<1> a variable is declared using the `def` keyword
<2> calling `toUpperCase` is allowed by the type checker
<3> calling `upper` will fail at compile time

The reason the call to `toUpperCase` works is because the type of `message` was _inferred_ as being a `String`.

===== Variables vs fields in type inference

It is worth noting that although the compiler performs type inference on local variables, it does *not* perform any kind
of type inference on fields, always falling back to the *declared type* of a field. To illustrate this, let's take a
look at this example:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=typeinference_field_vs_local_variable,indent=0]
----
<1> `someUntypedField` uses `def` as a declaration type
<2> `someTypedField` uses `String` as a declaration type
<3> we can assign *anything* to `someUntypedField`
<4> yet calling `toUpperCase` fails at compile time because the field is not typed properly
<5> we can assign a `String` to a field of type `String`
<6> and this time `toUpperCase` is allowed
<7> if we assign a `String` to a local variable
<8> then calling `toUpperCase` is allowed on the local variable

Why such a difference? The reason is _thread safety_. At compile time, we can't make *any* guarantee about the type of
a field. Any thread can access any field at any time and between the moment a field is assigned a variable of some
type in a method and the time is is used the line after, another thread may have changed the contents of the field. This
is not the case for local variables: we know if they "escape" or not, so we can make sure that the type of a variable is
constant (or not) over time. Note that even if a field is final, the JVM makes no guarantee about it, so the type checker
doesn't behave differently if a field is final or not.

TIP: This is one of the reasons why we recommend to use *typed* fields. While using `def` for local variables is perfectly
fine thanks to type inference, this is not the case for fields, which also belong to the public API of a class, hence the
type is important.

===== Collection literal type inference

Groovy provides a syntax for various type literals. There are three native collection literals in Groovy:

* lists, using the `[]` literal
* maps, using the `[:]` literal
* ranges, using the `(..,..)` literal

The inferred type of a literal depends on the elements of the literal, as illustrated in the following table:

[cols="2a,3a"]
|===
|Literal| Inferred type

|[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=empty_list_literal_inference,indent=0]
----
|`java.util.List`

|[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=list_literal_inference_simple,indent=0]
----
|`java.util.List<String>`

|[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=list_literal_inference_gstring,indent=0]
----
|`java.util.List<GString>` be careful, a `GString` is *not* a `String`!

|[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=empty_map_literal_inference,indent=0]
----
|`java.util.LinkedHashMap`

|[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=map_literal_inference_simple,indent=0]
----
|`java.util.LinkedHashMap<String,String>`

|[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=map_literal_inference_simple,indent=0]
----
|`java.util.LinkedHashMap<GString,String>` be careful, the key is a `GString`!

|[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=intRange_literal_inference,indent=0]
----
|`groovy.lang.IntRange`

|[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=charRange_literal_inference,indent=0]
----
|`groovy.lang.Range<String>` : uses the type of the bounds to infer the component type of the range

|===

As you can see, with the noticeable exception of the `IntRange`, the inferred type makes use of generics types to describe
the contents of a collection. In case the collection contains elements of different types, the type checker still performs
type inference of the components, but uses the notion of <<section-lub,least upper bound>>.

[[section-lub]]
===== Least upper bound

In Groovy, the _least upper bound_ of two types `A` and `B` is defined as a type which:

* superclass corresponds to the common super class of `A` and `B`
* interfaces correspond to the interfaces implemented by both `A` and `B`
* if `A` or `B` is a primitive type and that `A` isn't equal to `B`, the least upper bound of `A` and `B` is the least
upper bound of their wrapper types

If `A` and `B` only have one (1) interface in common and that their common superclass is `Object`, then the LUB of both
is the common interface.

The least upper bound represents the minimal type to which both `A` and `B` can be assigned. So for example, if `A` and `B`
are both `String`, then the LUB (least upper bound) of both is also `String`.

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=least_upper_bound_simple,indent=0]
----
<1> the LUB of `String` and `String` is `String`
<2> the LUB of `ArrayList` and `LinkedList` is their common super type, `AbstractList`
<3> the LUB of `ArrayList` and `List` is their only common interface, `List`
<4> the LUB of two identical interfaces is the interface itself
<5> the LUB of `Bottom1` and `Bottom2` is their superclass `Top`
<6> the LUB of two types which have nothing in common is `Object`

In those examples, the LUB is always representable as a normal, JVM supported, type. But Groovy internally represents the LUB
as a type which can be more complex, and that you wouldn't be able to use to define a variable for example. To illustrate this,
let's continue with this example:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=least_upper_bound_complex,indent=0]
----

What is the least upper bound of `Bottom` and `SerializableFooImpl`? They don't have a common super class (apart from `Object`),
but they do share 2 interfaces (`Serializable` and `Foo`), so their least upper bound is a type which represents the union of
two interfaces (`Serializable` and `Foo`). This type cannot be defined in the source code, yet Groovy knows about it.

In the context of collection type inference (and generic type inference in general), this becomes handy, because the type of the
components is inferred as the least upper bound. We can illustrate why this is important in the following example:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=least_upper_bound_collection_inference,indent=0]
----
<1> the `Greeter` interface defines a single method, `greet`
<2> the `Salute`  interface defines a single method, `salute`
<3> class `A` implements both `Greeter` and `Salute` but there's no explicit interface extending both
<4> same for `B`
<5> but `B` defines an additional `exit` method
<6> the type of `list` is inferred as "list of the LUB of `A` and `B`"
<7> so it is possible to call `greet` which is defined on both `A` and `B` through the `Greeter` interface
<8> and it is possible to call `salut` which is defined on both `A` and `B` through the `Salut` interface
<9> yet calling `exit` is a compile time error because it doesn't belong to the LUB of `A` and `B` (only defined in `B`)

The error message will look like:

----
[Static type checking] - Cannot find matching method Greeter or Salute#exit()
----

which indicates that the `exit` method is neither defines on `Greeter` nor `Salute`, which are the two interfaces defined
in the least upper bound of `A` and `B`.

===== instanceof inference

In normal, non type checked, Groovy, you can write things like:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=instanceof_inference,indent=0]
----
<1> guard the method call with an `instanceof` check
<2> make the call

The method call works because of dynamic dispatch (the method is selected at runtime). The equivalent code in Java would
require to cast `o` to a `Greeter` before calling the `greeting` method, because methods are selected at compile time:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=instanceof_java_equiv,indent=0]
----

However, in Groovy, even if you add `@TypeChecked` (and thus activate type checking) on the `doSomething` method, the
cast is *not* necessary. The compiler embeds _instanceof_ inference that makes the cast optional.

===== Flow typing

Flow typing is an important concept of Groovy in type checked mode and an extension of type inference. The idea is that
the compiler is capable of infering the type of variables in the flow of the code, not just at initialization:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=flowtyping_basics,indent=0]
----
<1> first, `o` is declared using `def` and assigned a `String`
<2> the compiler inferred that `o` is a `String`, so calling `toUpperCase` is allowed
<3> `o` is reassigned with a `double`
<4> calling `Math.sqrt` passes compilation because the compiler knows that at this point, `o` is a `double`

So the type checker is _aware_ of the fact that the concrete type of a variable is different over time. In particular,
if you replace the last assignment with:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=flowtyping_basics_fail,indent=0]
----

The type checker will now fail at compile time, because it knows that `o` is a `double` when `toUpperCase` is called,
so it's a type error.

It is important to understand that it is not the fact of declaring a variable with `def` that triggers type inference.
Flow typing works for *any* variable of any type. Declaring a variable with an explicit type only constraints what you
can assign to a variable:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=flowtyping_typeconstraints,indent=0]
----
<1> `list` is declared as an unchecked `List` and assigned a list literal of `String`s
<2> this line passes compilation because of flow typing: the type checker knows that `list` is at this point a `List<String>`
<3> but you can't assign a `String` to a `List` so this is a type checking error

You can also note that even if the variable is declared *without* generics information, the type checker knows what is
the component type. Therefore, such code would fail compilation:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=flowtyping_typeconstraints_failure,indent=0]
----
<1> `list` is inferred as `List<String>`
<2> so adding an `int` to a `List<String>` is a compile-time error

Fixing this requires adding an explicit generic type to the declaration:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=flowtyping_typeconstraints_fixed,indent=0]
----
<1> `list` declared as `List<? extends Serializable>` and initialized with an empty list
<2> elements added to the list conform to the declaration type of the list
<3> so adding an `int` to a `List<? extends Serializable>` is allowed

Flow typing has been introduced to reduce the difference in semantics between classic and static Groovy. In particular,
consider the behavior of this code in Java:

[source,java]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingJavaTest.java[tags=java_method_selection_head,indent=0]
include::{projectdir}/src/spec/test/typing/TypeCheckingJavaTest.java[tags=java_method_selection_body,indent=0]
----
<1> `o` is declared as an `Object` and assigned a `String`
<2> we call the `compute` method with `o`
<3> and print the result

In Java, this code will output `0`, because method selection is done at compile time and based on the *declared* types.
So even if `o` is a `String` at runtime, it is still the `Object` version which is called, because `o` has been declared
as an `Object`. To be short, in Java, declared types are most important, be it variable types, parameter types or return
types.

In Groovy, we could write:

[source,groovy]
----
include::{projectdir}/src/spec/test/typing/TypeCheckingTest.groovy[tags=groovy_method_selection,indent=0]
----

But this time, it will return `6`, because the method which is chosen is chosen *at runtime*, based on the _actual_
argument types. So at runtime, `o` is a `String` so the `String` variant is used. Note that this behavior has nothing
to do with type checking, it's the way Groovy works in general: dynamic dispatch.

In type checked Groovy, we want to make sure the type checker selects the same method *at compile time*, that the runtime
would choose. It is not possible in general, due to the semantics of the language, but we can make things better with flow
typing. With flow typing, `o` is _inferred_ as a `String` when the `compute` method is called, so the version which takes
a `String` and returns an `int` is chosen. This means that we can infer the return type of the method to be an `int`, and
not a `String`. This is important for subsequent calls and type safety.

So in type checked Groovy, flow typing is a very important concept, which also implies that if `@TypeChecked` is applied,
methods are selected based on the _inferred types_ of the arguments, not on the declared types. This doesn't ensure 100%
type safety, because the type checker _may_ select a wrong method, but it ensures the closest semantics to dynamic Groovy.


=== Static compilation (TBD)

